<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DS2482-RK: DS2482 Library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DS2482-RK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="class_d_s2482.html" title="Class for DS2482 devices. ">DS2482</a> Library </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The <a class="el" href="class_d_s2482.html" title="Class for DS2482 devices. ">DS2482</a> is an I2C to 1-wire interface chip. It comes in two versions, the DS2482-100 (1-port) and DS2482-800 (8-port). Using an interface chip is helpful because most DS18B20/1-wire libraries use timing sensitive code and may run for extended periods with interrupts disabled. This can cause the rest of your program to have poor performance.</p>
<p>The library fully supports both single-drop and multi-drop modes, allowing many DS18B20 sensors on a single 1-wire bus.</p>
<p>The <a class="el" href="class_d_s2482.html" title="Class for DS2482 devices. ">DS2482</a> library is completely asynchronous, never blocking for more than the time to do an I2C read or write. Interrupts are never disabled.</p>
<p>Every call uses a C++11 lambda completion handler. The second part of this document has a bit of explanation of why and how it works.</p>
<p>The <a class="el" href="class_d_s2482.html" title="Class for DS2482 devices. ">DS2482</a> also has an internal transistor to pull the 1-wire bus high during temperature conversion and flash writes. This allows the use of parasitic power mode, requiring only two wires for sensors (DQ and GND), with no separate power line. The library supports this as well.</p>
<h2>Common tasks</h2>
<h3>Get temperature of one sensor (single-drop)</h3>
<div class="fragment"><div class="line">#include &quot;DS2482.h&quot;</div><div class="line"></div><div class="line">SerialLogHandler logHandler;</div><div class="line"></div><div class="line">DS2482 ds(Wire, 3);</div><div class="line"></div><div class="line">const unsigned long CHECK_PERIOD = 30000;</div><div class="line">unsigned long lastCheck = 5000 - CHECK_PERIOD;</div><div class="line"></div><div class="line">void setup() {</div><div class="line">    Serial.begin(9600);</div><div class="line">    ds.setup();</div><div class="line"></div><div class="line">    DS2482DeviceReset::run(ds, [](DS2482DeviceReset&amp;, int status) {</div><div class="line">        Serial.printlnf(&quot;deviceReset=%d&quot;, status);</div><div class="line">    });</div><div class="line"></div><div class="line">    Serial.println(&quot;setup complete&quot;);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">void loop() {</div><div class="line"></div><div class="line">    ds.loop();</div><div class="line"></div><div class="line">    if (millis() - lastCheck &gt;= CHECK_PERIOD) {</div><div class="line">        lastCheck = millis();</div><div class="line"></div><div class="line">        // For single-drop you can pass an empty address to get the temperature of the only</div><div class="line">        // sensor on the 1-wire bus</div><div class="line">        DS24821WireAddress addr;</div><div class="line"></div><div class="line">        DS2482GetTemperatureCommand::run(ds, addr, [](DS2482GetTemperatureCommand&amp;, int status, float tempC) {</div><div class="line">            if (status == DS2482Command::RESULT_DONE) {</div><div class="line">                char buf[32];</div><div class="line">                snprintf(buf, sizeof(buf), &quot;%.4f&quot;, tempC);</div><div class="line"></div><div class="line">                Serial.printlnf(&quot;temperature=%s deg C&quot;, buf);</div><div class="line">                Particle.publish(&quot;temperature&quot;, buf, PRIVATE);</div><div class="line">            }</div><div class="line">            else {</div><div class="line">                Serial.printlnf(&quot;DS2482GetTemperatureCommand failed status=%d&quot;, status);</div><div class="line">            }</div><div class="line">        });</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h3>Get temperatures of multiple sensors (multi-drop)</h3>
<div class="fragment"><div class="line">#include &quot;DS2482.h&quot;</div><div class="line"></div><div class="line">SerialLogHandler logHandler;</div><div class="line"></div><div class="line">DS2482 ds(Wire, 3);</div><div class="line"></div><div class="line">DS2482DeviceListStatic&lt;10&gt; deviceList;</div><div class="line">const unsigned long CHECK_PERIOD = 30000;</div><div class="line">unsigned long lastCheck = 10000 - CHECK_PERIOD;</div><div class="line"></div><div class="line">void setup() {</div><div class="line">    Serial.begin(9600);</div><div class="line">    ds.setup();</div><div class="line"></div><div class="line">    DS2482DeviceReset::run(ds, [](DS2482DeviceReset&amp;, int status) {</div><div class="line">        Serial.printlnf(&quot;deviceReset=%d&quot;, status);</div><div class="line">        DS2482SearchBusCommand::run(ds, deviceList, [](DS2482SearchBusCommand &amp;obj, int status) {</div><div class="line"></div><div class="line">            if (status != DS2482Command::RESULT_DONE) {</div><div class="line">                Serial.printlnf(&quot;DS2482SearchBusCommand status=%d&quot;, status);</div><div class="line">                return;</div><div class="line">            }</div><div class="line"></div><div class="line">            Serial.printlnf(&quot;Found %u devices&quot;, deviceList.getDeviceCount());</div><div class="line">        });</div><div class="line">    });</div><div class="line"></div><div class="line">    Serial.println(&quot;setup complete&quot;);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line">void loop() {</div><div class="line"></div><div class="line">    ds.loop();</div><div class="line"></div><div class="line">    if (millis() - lastCheck &gt;= CHECK_PERIOD) {</div><div class="line">        lastCheck = millis();</div><div class="line"></div><div class="line">        if (deviceList.getDeviceCount() &gt; 0) {</div><div class="line"></div><div class="line">            DS2482GetTemperatureForListCommand::run(ds, deviceList, [](DS2482GetTemperatureForListCommand&amp;, int status, DS2482DeviceList &amp;deviceList) {</div><div class="line">                if (status != DS2482Command::RESULT_DONE) {</div><div class="line">                    Serial.printlnf(&quot;DS2482GetTemperatureForListCommand status=%d&quot;, status);</div><div class="line">                    return;</div><div class="line">                }</div><div class="line"></div><div class="line">                Serial.printlnf(&quot;got temperatures!&quot;);</div><div class="line"></div><div class="line">                for(size_t ii = 0; ii &lt; deviceList.getDeviceCount(); ii++) {</div><div class="line">                    Serial.printlnf(&quot;%s valid=%d C=%f F=%f&quot;,</div><div class="line">                            deviceList.getAddressByIndex(ii).toString().c_str(),</div><div class="line">                            deviceList.getDeviceByIndex(ii).getValid(),</div><div class="line">                            deviceList.getDeviceByIndex(ii).getTemperatureC(),</div><div class="line">                            deviceList.getDeviceByIndex(ii).getTemperatureF());</div><div class="line">                }</div><div class="line"></div><div class="line">            });</div><div class="line">        }</div><div class="line">        else {</div><div class="line">            Serial.printlnf(&quot;no devices found&quot;);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h3>Multi-drop with parasitic power</h3>
<p>Just as the previous example, except within loop the call to D2482GetTemperatureListCommand::run has an extra optional fluent parameter, <code>.withParasiticPower()</code>.</p>
<div class="fragment"><div class="line">DS2482GetTemperatureForListCommand::run(ds, deviceList, [](DS2482GetTemperatureForListCommand&amp;, int status, DS2482DeviceList &amp;deviceList) {</div><div class="line">    if (status != DS2482Command::RESULT_DONE) {</div><div class="line">        Serial.printlnf(&quot;DS2482GetTemperatureForListCommand status=%d&quot;, status);</div><div class="line">        return;</div><div class="line">    }</div><div class="line"></div><div class="line">    Serial.printlnf(&quot;got temperatures!&quot;);</div><div class="line"></div><div class="line">    for(size_t ii = 0; ii &lt; deviceList.getDeviceCount(); ii++) {</div><div class="line">        Serial.printlnf(&quot;%s valid=%d C=%f F=%f&quot;,</div><div class="line">                deviceList.getAddressByIndex(ii).toString().c_str(),</div><div class="line">                deviceList.getDeviceByIndex(ii).getValid(),</div><div class="line">                deviceList.getDeviceByIndex(ii).getTemperatureC(),</div><div class="line">                deviceList.getDeviceByIndex(ii).getTemperatureF());</div><div class="line">    }</div><div class="line"></div><div class="line">}).withParasiticPower();</div></div><!-- fragment --><h3>Multi-drop with JSON publish</h3>
<p>This example is like the previous, except it publishes multiple sensor values via a single Particle.publish in JSON format (up to 10 DS18B20s supported).</p>
<div class="fragment"><div class="line">#include &quot;DS2482.h&quot;</div><div class="line">#include &quot;JsonParserGeneratorRK.h&quot;</div><div class="line"></div><div class="line">SerialLogHandler logHandler;</div><div class="line"></div><div class="line">DS2482 ds(Wire, 3);</div><div class="line"></div><div class="line">DS2482DeviceListStatic&lt;10&gt; deviceList;</div><div class="line">JsonWriterStatic&lt;256&gt; jsonWriter;</div><div class="line"></div><div class="line">const unsigned long CHECK_PERIOD = 30000;</div><div class="line">unsigned long lastCheck = 10000 - CHECK_PERIOD;</div><div class="line"></div><div class="line">void setup() {</div><div class="line">    Serial.begin(9600);</div><div class="line">    ds.setup();</div><div class="line"></div><div class="line">    DS2482DeviceReset::run(ds, [](DS2482DeviceReset&amp;, int status) {</div><div class="line">        Serial.printlnf(&quot;deviceReset=%d&quot;, status);</div><div class="line">        DS2482SearchBusCommand::run(ds, deviceList, [](DS2482SearchBusCommand &amp;obj, int status) {</div><div class="line"></div><div class="line">            if (status != DS2482Command::RESULT_DONE) {</div><div class="line">                Serial.printlnf(&quot;DS2482SearchBusCommand status=%d&quot;, status);</div><div class="line">                return;</div><div class="line">            }</div><div class="line"></div><div class="line">            Serial.printlnf(&quot;Found %u devices&quot;, deviceList.getDeviceCount());</div><div class="line">        });</div><div class="line">    });</div><div class="line"></div><div class="line">    Serial.println(&quot;setup complete&quot;);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line">void loop() {</div><div class="line"></div><div class="line">    ds.loop();</div><div class="line"></div><div class="line">    if (millis() - lastCheck &gt;= CHECK_PERIOD) {</div><div class="line">        lastCheck = millis();</div><div class="line"></div><div class="line">        if (deviceList.getDeviceCount() &gt; 0) {</div><div class="line"></div><div class="line">            DS2482GetTemperatureForListCommand::run(ds, deviceList, [](DS2482GetTemperatureForListCommand&amp;, int status, DS2482DeviceList &amp;deviceList) {</div><div class="line">                if (status != DS2482Command::RESULT_DONE) {</div><div class="line">                    Serial.printlnf(&quot;DS2482GetTemperatureForListCommand status=%d&quot;, status);</div><div class="line">                    return;</div><div class="line">                }</div><div class="line"></div><div class="line">                Serial.printlnf(&quot;got temperatures!&quot;);</div><div class="line"></div><div class="line">                // Initialize the JsonWriter object and sets it to send 2 decimal places</div><div class="line">                jsonWriter.init();</div><div class="line">                jsonWriter.setFloatPlaces(2);</div><div class="line"></div><div class="line">                // startObject is for the outer object and must be balanced with finishObjectOrArray.</div><div class="line">                jsonWriter.startObject();</div><div class="line"></div><div class="line">                // Write the actual temperatures</div><div class="line">                for(size_t ii = 0; ii &lt; deviceList.getDeviceCount(); ii++) {</div><div class="line">                    if (deviceList.getDeviceByIndex(ii).getValid()) {</div><div class="line">                        // This creates a key of the form &quot;t0&quot; for the first, &quot;t1&quot; for the second, ...</div><div class="line">                        char key[4];</div><div class="line">                        key[0] = &#39;t&#39;;</div><div class="line">                        key[1] = &#39;0&#39; + ii;</div><div class="line">                        key[2] = 0;</div><div class="line"></div><div class="line">                        // Inserts the float as a key value pair</div><div class="line">                        jsonWriter.insertKeyValue(key, deviceList.getDeviceByIndex(ii).getTemperatureC());</div><div class="line">                    }</div><div class="line">                }</div><div class="line"></div><div class="line">                jsonWriter.finishObjectOrArray();</div><div class="line"></div><div class="line">                Serial.println(jsonWriter.getBuffer());</div><div class="line">                Particle.publish(&quot;temperature&quot;, jsonWriter.getBuffer(), PRIVATE);</div><div class="line"></div><div class="line">                // Example output:</div><div class="line">                // {&quot;t0&quot;:23.56,&quot;t1&quot;:23.12}</div><div class="line">            });</div><div class="line">        }</div><div class="line">        else {</div><div class="line">            Serial.printlnf(&quot;no devices found&quot;);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Example serial output:</p>
<div class="fragment"><div class="line">got temperatures!</div><div class="line">{&quot;t0&quot;:23.56,&quot;t1&quot;:23.12}</div></div><!-- fragment --><p>Because the 1-wire bus search is deterministic, it will always returns the sensors in the same order, sorted by 1-wire device address (increasing).</p>
<h2>About lambdas, fluent-style and more</h2>
<p>The <a class="el" href="class_d_s2482.html" title="Class for DS2482 devices. ">DS2482</a> library uses a C++11 style of coding that is very powerful, but will probably be foreign to you if you learned old-school C and C++. It's actually more like the way Javascript/node.js is programmed.</p>
<p>One of the main advantages of the <a class="el" href="class_d_s2482.html" title="Class for DS2482 devices. ">DS2482</a> library is that it's completely asynchronous. No call blocks for more than the time it takes to make an I2C transfer. This is important because getting a temperature sensor reading can take 750 milliseconds, and most DS18B20 software libraries block during conversion.</p>
<h3>Synchronous way</h3>
<p>Using the <a href="https://build.particle.io/libs/DS18B20/0.1.7/tab/DS18B20.cpp">DS18B20 library</a>, you make a call like this:</p>
<div class="fragment"><div class="line">float tempC = ds.getTemperature(addr);</div></div><!-- fragment --><p>The main loop thread is blocked during this call for 750 milliseconds, which may affect performance elsewhere in your code.</p>
<h3>State machines</h3>
<p>One common way of implementing asynchronous code is state machines. This is a bit of pseudo-code of what a state machine version might look like.</p>
<div class="fragment"><div class="line">void loop() {</div><div class="line">    switch(state) {</div><div class="line">    case GET_TEMPERATURE_STATE:</div><div class="line">        ds.startTemperature();</div><div class="line">        state = TEMPERATURE_WAIT_STATE;</div><div class="line">        break;</div><div class="line"></div><div class="line">    case TEMPERATURE_WAIT_STATE:</div><div class="line">        if (ds.isTemperatureDone()) {</div><div class="line">            float temp = ds.readTemperature();</div><div class="line">            state = ANOTHER_STATE;</div><div class="line">        }</div><div class="line">        break;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>State machines are really powerful, and actually how the <a class="el" href="class_d_s2482.html" title="Class for DS2482 devices. ">DS2482</a> library is implemented internally, but can get a bit unwieldy.</p>
<h3>Callbacks</h3>
<p>Callback functions are another common way of handling asynchronous code, like in this pseudo-code example:</p>
<div class="fragment"><div class="line">void temperatureCallback(float temp) {</div><div class="line">    Serial.printlnf(&quot;got temperature %f&quot;, temp);</div><div class="line">}</div><div class="line"></div><div class="line">void loop() {</div><div class="line">    if (millis() - lastCheck &gt;= CHECK_PERIOD) {</div><div class="line">        lastCheck = millis();</div><div class="line">        ds.getTemperature(temperatureCallback);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>The problem with callbacks is that it's a pain to pass state data to the callback, and it requires some effort to make a callback handler a class member function.</p>
<h3>The Lambda</h3>
<p>The lambda solves some of the problems with callbacks. Here's an example of doing an asynchronous device reset call:</p>
<div class="fragment"><div class="line">void setup() {</div><div class="line">    Serial.begin(9600);</div><div class="line">    ds.setup();</div><div class="line"></div><div class="line">    DS2482DeviceReset::run(ds, [](DS2482DeviceReset&amp;, int status) {</div><div class="line">        Serial.printlnf(&quot;deviceReset=%d&quot;, status);</div><div class="line">    });</div><div class="line"></div><div class="line">    Serial.println(&quot;setup complete&quot;);</div><div class="line">}</div></div><!-- fragment --><p>The syntax is a little weird, and I'll get to that a moment, however the important thing is that this block of code, the lambda, is executed later.</p>
<div class="fragment"><div class="line">[](DS2482DeviceReset&amp;, int status) {</div><div class="line">    Serial.printlnf(&quot;deviceReset=%d&quot;, status);</div><div class="line">}</div></div><!-- fragment --><p>The</p>
<div class="fragment"><div class="line">setup complete</div></div><!-- fragment --><p>message appears next.</p>
<p>When the asynchronous device reset completes, the block runs and</p>
<div class="fragment"><div class="line">deviceReset=1</div></div><!-- fragment --><p>will likely be printed to the serial console. Note, however, that the lines after the block, like printing setup complete! won't happen a second time.</p>
<p>A declaration of a lambda function looks like</p>
<div class="fragment"><div class="line">[](DS2482DeviceReset&amp;, int status) {</div><div class="line">    // Code goes here</div><div class="line">}</div></div><!-- fragment --><p>The <code>[]</code> part is the capture, which we'll discuss in a moment, and <code>(<a class="el" href="class_d_s2482_device_reset.html" title="Resets the DS2482. ">DS2482DeviceReset</a>&amp;, int status)</code> is a function parameter declaration. Basically the callback is a function that takes two parameters, a <code><a class="el" href="class_d_s2482_device_reset.html" title="Resets the DS2482. ">DS2482DeviceReset</a>&amp;</code> object (not used here) and an <code>int status</code> (for status).</p>
<h3>Nesting calls</h3>
<p>This example demonstrates two handy things:</p>
<ul>
<li>Making your lambda be a class member</li>
<li>Nesting lambdas for sequential operations</li>
</ul>
<div class="fragment"><div class="line">void TestClass::check() {</div><div class="line">    DS2482SearchBusCommand::run(ds, deviceList, [this](DS2482SearchBusCommand &amp;obj, int status) {</div><div class="line"></div><div class="line">        if (status != DS2482Command::RESULT_DONE) {</div><div class="line">            Serial.printlnf(&quot;DS2482SearchBusCommand status=%d&quot;, status);</div><div class="line">            return;</div><div class="line">        }</div><div class="line"></div><div class="line">        if (deviceList.getDeviceCount() == 0) {</div><div class="line">            Serial.println(&quot;no devices&quot;);</div><div class="line">            return;</div><div class="line">        }</div><div class="line"></div><div class="line">        DS2482GetTemperatureForListCommand::run(ds, obj.getDeviceList(), [this](DS2482GetTemperatureForListCommand&amp;, int status, DS2482DeviceList &amp;deviceList) {</div><div class="line">            if (status != DS2482Command::RESULT_DONE) {</div><div class="line">                Serial.printlnf(&quot;DS2482GetTemperatureForListCommand status=%d&quot;, status);</div><div class="line">                return;</div><div class="line">            }</div><div class="line"></div><div class="line">            Serial.printlnf(&quot;got temperatures!&quot;);</div><div class="line"></div><div class="line">            for(size_t ii = 0; ii &lt; deviceList.getDeviceCount(); ii++) {</div><div class="line">                Serial.printlnf(&quot;%s valid=%d C=%f F=%f&quot;,</div><div class="line">                        deviceList.getAddressByIndex(ii).toString().c_str(),</div><div class="line">                        deviceList.getDeviceByIndex(ii).getValid(),</div><div class="line">                        deviceList.getDeviceByIndex(ii).getTemperatureC(),</div><div class="line">                        deviceList.getDeviceByIndex(ii).getTemperatureF());</div><div class="line">            }</div><div class="line"></div><div class="line">        });</div><div class="line">    });</div><div class="line">}</div></div><!-- fragment --><p>You'll notice the slightly different syntax in the capture, the part in the square brackets:</p>
<div class="fragment"><div class="line">DS2482SearchBusCommand::run(ds, deviceList, [this](DS2482SearchBusCommand &amp;obj, int status) {</div></div><!-- fragment --><p>Instead of just being <code>[]</code> it's <code>[this]</code>. That means that <code>this</code>, your class instance, is captured, and available inside the lambda. It essentially makes the inner function a class member, available to access class member functions and variables.</p>
<p>You can capture multiple variables, separated by commas. You can capture function parameters and local variables, for example.</p>
<p>The other thing is that you can nest these, so each new indent in occurs at a later time. If you don't like that style, however, you can just split your code into separate member functions like this:</p>
<div class="fragment"><div class="line">void TestClass::searchBus() {</div><div class="line"></div><div class="line">    DS2482SearchBusCommand::run(ds, deviceList, [this](DS2482SearchBusCommand &amp;obj, int status) {</div><div class="line"></div><div class="line">        if (status != DS2482Command::RESULT_DONE) {</div><div class="line">            Serial.printlnf(&quot;DS2482SearchBusCommand status=%d&quot;, status);</div><div class="line">            return;</div><div class="line">        }</div><div class="line"></div><div class="line">        if (deviceList.getDeviceCount() == 0) {</div><div class="line">            Serial.println(&quot;no devices&quot;);</div><div class="line">            return;</div><div class="line">        }</div><div class="line"></div><div class="line">        getTemperatures();</div><div class="line">    });</div><div class="line">}</div><div class="line"></div><div class="line">void TestClass::getTemperatures() {</div><div class="line"></div><div class="line">    DS2482GetTemperatureForListCommand::run(ds, deviceList, [this](DS2482GetTemperatureForListCommand&amp;, int status, DS2482DeviceList &amp;deviceList) {</div><div class="line">        if (status != DS2482Command::RESULT_DONE) {</div><div class="line">            Serial.printlnf(&quot;DS2482GetTemperatureForListCommand status=%d&quot;, status);</div><div class="line">            return;</div><div class="line">        }</div><div class="line"></div><div class="line">        Serial.printlnf(&quot;got temperatures!&quot;);</div><div class="line"></div><div class="line">        for(size_t ii = 0; ii &lt; deviceList.getDeviceCount(); ii++) {</div><div class="line">            Serial.printlnf(&quot;%s valid=%d C=%f F=%f&quot;,</div><div class="line">                    deviceList.getAddressByIndex(ii).toString().c_str(),</div><div class="line">                    deviceList.getDeviceByIndex(ii).getValid(),</div><div class="line">                    deviceList.getDeviceByIndex(ii).getTemperatureC(),</div><div class="line">                    deviceList.getDeviceByIndex(ii).getTemperatureF());</div><div class="line">        }</div><div class="line">    });</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><h3>Optional parameters</h3>
<p>Within the library, optional parameters are passed fluent-style instead of using C++ optional parameters. The fluent-style parameters are easier to identify and don't depend on order. For example:</p>
<div class="fragment"><div class="line">DS2482GetTemperatureCommand::run(ds, addr, [this,completion](DS2482GetTemperatureCommand&amp;, int status, float t) {</div><div class="line">        if (status != DS2482Command::RESULT_DONE) {</div><div class="line">            Log.error(&quot;FAILURE DS2482GetTemperatureCommand failed %d bus %s&quot;, status, name.c_str());</div><div class="line">            completion();</div><div class="line">            return;</div><div class="line">        }</div><div class="line"></div><div class="line">        testsComplete(completion);</div><div class="line">    }).withParasiticPower(isParasiticPowered).withMaxRetries(1);</div></div><!-- fragment --><p>Of note:</p>
<ul>
<li>The optional parameters go after the <code>})</code> that closes the run command.</li>
<li>You can chain as many or as few as you want in any order.</li>
<li>The names all begin with <code>with</code>.</li>
</ul>
<p>In this example, it uses parasitic power or not based on the member variable <code>isParasiticPowered</code> and limits the number of retries to 1.</p>
<h3>Run methods</h3>
<p>All of the asynchronous functions are implemented as separate classes with a static run method. For example <code><a class="el" href="class_d_s2482_get_temperature_command.html#a91c9ee5048047d209e3dd1effa1ba179" title="Gets the temperatures for a DS18B20 sensor on the 1-wire bus. ">DS2482GetTemperatureCommand::run</a></code>.</p>
<p>This is done because the objects need to be allocated on the heap (using new), not stack allocated. Since they continue after your function returns, stack allocated classes wouldn't work because they would go away when the enclosing function returns.</p>
<p>The run methods take care of allocated the objects and enqueueing them for execution so they make sure the objects gets delete later, as well.</p>
<h2>Library documentation</h2>
<p>The full library documentation can be found here. It's automatically generated from the .h file, so you can read the comments there as well.</p>
<h2>Hardware examples</h2>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
